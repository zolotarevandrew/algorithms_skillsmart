1) Сохранение данных после верификации персоны из стороннего сервиса
Сейчас для хранения данных верифицированной персоны используется одна табличка и хранятся только последние данные полученные с документов.
При этом изменения статусов верификации записываются исторически (используя хэширование на основе данных вебхука, время проверки и еще пара полей)

Было бы удобным хранить данные верифицированной персоны (из документов) также исторически как и изменения статусов.
 
Добавление столбца текущей версии полей объекта в эту таблицу, позволило бы иметь ряд различных версий объектов и в коде и из коробки
получить версионирование и обратную совместимость, о котором говорилось в уроке.
При этом таким образом легко защищаемся от изменений в апи стороннего сервиса, просто заведем новую версию и сделаем новый маппинг полей.  

2) Баннеры для клиента
В бд хранятся баннеры, которые приоритетно показывают клиенту, какой этап открытия счета сейчас или что ему еще нужно сделать (дозаполнить данные, перепройти верификацию).

Поскольку фронтенду всеравно (а для мобилок используется вебвью) и мы отдаем 
- payload (набор полей,не обязательный по которому отрисуются дополнительные данные )
- тип баннера

То будет здравой идея версионирования баннеров, с возможностью отката на предыдущую версию (если какой-нибудь А/Б тест не зашел).
- Также добавляем версию в бд.
- По-хорошему учим фронт работать с динамическими данными баннеров (чтобы каждый раз не передавать версию на фронтенд)
- В коде имеем ряд версий баннеров с разным payload (отдельные типы)
- Возвращаем ответ на фронтенд в зависимости от типа баннера и версии в общем переиспользуемом формате 

3) Классический event sourcing
Храним набор событий в базе данных, состояние объекта высчитываем на лету( + используем снэпшоты на конкретный момент времени, чтобы не доставать все события)
Можем возвратится к конкретному состоянию (создать снэпшот).
- Получаем аудит из коробки.
- Добавление новых видов событий не потребует изменения
- На основе версий событий можем понимать какой объект лучше построить (разные версии сущностей, были изменения в бизнес требованиях).
Как пример любая система заказов.


Итого - избыточность классная вещь, никогда не думал о ней в разрезе обратной совместимости. 
Это очень мощный инструмент,который часто бывает нужен, особенно в стартапах или при сильном росте продукта.
Возьму себе на вооружение, благо стоимость хранения сейчас относительно не высокая.