Зависимость от более строгого результата, чем гарантируется спецификацией.

1) зависимость от operate компонента камунды для поиска процессов

При переходе на камунду8
Завязались на поиск процессов из operate, потому что ранее в камунде 7 было схожее апи по поиску процессов.
Естественно в документации не было описано, что стоит на это завязываться и завязались сами, посчитав, что это хорошая идея.

Далее оказалось, что operate использует эластик и туда складываются только исторические данные. Соот-во присутствует eventual consistency.
При этом, мы на каждый чих искали процесс перед отправкой туда сообщения или стартом нового процесса - чтобы получить его id.
Тем самым создавали серьезную нагрузку на эластик, грузив его лишними запросами. (даже ретраи делали для получения процесса..)

Дополнительно оказалось, что при обработке каждой команды внутри камунды, синхронно шлется запрос на сохранение информации в эластик - выяснили опытным путем;
Таким образом - выстрелили себе в ногу и сами перегружали систему.

Порешали - просто сохраняя информацию о процессе при его создании и окончании себе в базу.

2) Калькулятор завершения шагов (Example2)

Полагаемся на текущие особенности реализации стейт машины, что LastSteps(последние шаги) и ReadyForReviewSteps(шаги для перехода в ревью) конкретные шаги и должны присутствовать.

При этом по спецификации
- шаги могут переоткрываться даже после перехода в ревью (то есть быть не Completed);
- для открытия счета (EFinomOnboardingStepCompletionStatus.Completed), онбордингу достаточно находится в определенном статусе.

-----
Зависимость от возможности использовать более мягкие реализации, чем гарантирует спецификация (если текущая реализация более щадящая, чем гарантирует спецификация)

1) уже приводил пример
команда бэкофиса завязалась на получение банккода из нашего онбординга, сами написали код в нашем микросервисе и думали, 
что банккод всегда один в рамках компании, но когда появилось два онбординга в разных банках, все сломалось.
   
Логично, что банккод в рамках компании устанавливается 1 раз и меняться не будет.
Был давно сделан синк в базу бэкофиса, сохранялся банккод, туда и надо было смотреть.

2) Ограничения сбора полей по конкретным странам

По спецификации, конкретные типы бизнеса в стране, могут иметь свои особенности валидации и нормализации полей.

Слой хранения данных по компании - не предусматривает обязательность валидации и нормализации полей по конкретному типу бизнеса и стране.
Это делается на уровне бизнес логики.

При этом, много где данные сохраняются через слой хранилища напрямую, без какой-либо нормализации, что приводит к очевидным проблемам.


-----

Принцип робастности/надёжности Постела
Из примера выше видно, что данный принцип у нас соблюдается :)
При этом при интеграции с внешними системами, происходит абсолютно тоже самое и кривые данные могут протечь в базу без особых проблем.

Избавиться от него достаточно просто, нужно очень строго подходить к любым данным попадающим в систему,
проводить их валидацию и нормализацию заранее, иметь заготовленные таблицы по конкретным типам данных и диапазонов их значений.

-----

Потренируйтесь общаться с коллегами на третьем логическом уровне (на уровне спецификаций и стабильных гарантий)

Попробовал, это сделать при общении с продактом, тем самым улучшил понимание спецификации на всех уровнях.
Поправили ТЗ с учетом конкретных возможных состояний верификации (NotStarted, SomethingWentWrong, VerificationInProgress, VerificationResultAwaiting, Verified).
Проговорили пред и постусловия на конкретные изменения и также добавили/закрепили это в ТЗ, а затем и в коде.

Таким образом, ТЗ стало отражать спецификацию и для продактов, тестировщиков, разработчиков.

-----

Итого - разработка через спецификацию на практике, приносит ощутимые результаты (если заранее проговариваются возможные пред и постусловия)
- уменьшает время на разработку;
- снижает кол-во багов;
- увеличивает надежность системы в будущем, за счет стабильных гарантий;


 


