1) https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.DependencyInjection

ServiceDescriptor
- Хранит ссылку на тип интерфейса и реализации.
- Определяет время жизни (lifetime).
- Содержит object key, если зависимость должна быть отличаема по ключу.
- Имеет ссылку на делегат (implementation factory), если указано кастомное создание экземпляра.
- Включает множество методов для различных нужд, что затрудняет чтение класса (лучше было бы вынести их в extension-методы).

ServiceCollection
- Представляет собой простую обёртку над списком ServiceDescriptor.
- Использует обычный List<ServiceDescriptor>, а не ConcurrentDictionary.
- Методы (AddSingleton, AddTransient и др.) реализованы как extension-методы и просто добавляют ServiceDescriptor в ServiceCollection.
- При добавлении ServiceDescriptor выполняется проверка на существование, проходя по всей коллекции. Внутреннее использование Dictionary могло бы повысить производительность.

ServiceProvider
- Провайдер сервисов, создаваемый на основе ServiceCollection.
- Хранит ConcurrentDictionary, где:
  - Ключ: ServiceIdentifier (тип сервиса + ключ, если есть).
  - Значение: ServiceAccessor (делегат для разрешения сервиса + CallSite).
- При получении сервиса проверяет, есть ли он в ConcurrentDictionary. Если нет, создаёт и кэширует.

CallSite
- Представляет способ разрешения зависимости - через конструктор, фабрику и другие механизмы.

CallSiteFactory
- Строит и кэширует CallSite для оптимального разрешения зависимостей.

CallSiteRuntimeResolver
- Реализован по паттерну Visitor.
- Создаёт экземпляры типов на основе CallSite.
- Использует ServiceProviderEngineScope, который кэширует объекты в зависимости от времени их жизни.
- ResolvedServices (обычный Dictionary) используется для хранения уже созданных сервисов.
- Если сервис отсутствует в ResolvedServices, создаётся новый экземпляр через CallSiteFactory и добавляется в ResolvedServices с lock для потокобезопасности.

Что узнал нового:
- делегат кэшируется как поле в классе, чтобы не делать лишних аллокаций делегатов, проверил в IL Viewer, интересная техника и важная.

2) https://github.com/DapperLib/Dapper

Dapper — обертка над ADO.NET, которая представляет собой набор extension-методов.
- Dapper хранит кэш для маппингов, который можно вычистить принудительно.
- typeMap хранит соответствие типов .NET и типов из ADO.NET.
- typeHandlers хранит обработчики типов в статическом поле. 
- TypeHandlerCache кэширует typeHandlers.
- CommandDefinition — обертка для передачи команды, сделанная в виде структуры, чтобы не аллоцировать лишнюю память. 
В методы вызова передается по ссылке, чтобы избежать копирования на стеке.

При вызове запросов через Query используется кэш запросов (CacheInfo), который содержит Action<IDbCommand, object?> Reader — логику установки и привязки параметров для SQL-запросов.
- Если передается object или DapperRow, в коде много боксинга и лишних аллокаций — лучше не использовать.
- Если передается конкретный тип, используется IL-генерация для быстрого маппинга (возможно имеет смысл «прогревать» кэш Dapper наиболее частыми запросами при старте приложения).
 
Что узнал нового:
- В нашем коде SqlMapper.AddTypeHandler добавлялся с использованием кастомного lock, но блокировка уже добавлена внутри Dapper.
- Есть класс DynamicParameters, если нужно динамически управлять параметрами, например, для динамических UPDATE, когда нужно обновить только конкретные поля. Это очень удобно.
- Узнал про технику Snapshot/Mutate/Swap.
- Generic-классы в .NET создают отдельные версии статических полей для каждого конкретного типа.

3) https://github.com/camunda-community-hub/zeebe-client-csharp

Обертка для работы с gRPC-клиентом Zeebe.
- Поллинг запускает `Task.Run`, который в цикле пытается получить джобы по gRPC.
- Если запущено более `MaxJobsActive` джобов, то поллинг происходить не будет. Если запущено меньше, то запрашивается до предела `MaxJobsActive - currentJobsActive`.
- Ошибки `StatusCode.DeadlineExceeded`, `StatusCode.Cancelled` и `StatusCode.ResourceExhausted` почему-то логируются только на уровне `Trace`, хотя это очень важная статистика.
- В коде используется `Thread.VolatileRead(ref currentJobsActive)`, хотя можно просто пометить переменную `volatile`, без использования устаревшей конструкции.

Что узнал нового:
- Поскольку используется TPL BufferBlock, `MaxDegreeOfParallelism` указывает, будет ли каждая джоба обрабатываться последовательно или нет. В некоторых местах у нас вообще стоит `1`, надо будет исправить.


Итого - взял себе на заметку много полезных фишек из этих библиотек. 
Буду продолжать эту практику на постоянной основе. 
Уже стал чаще заглядывать в исходники .NET.