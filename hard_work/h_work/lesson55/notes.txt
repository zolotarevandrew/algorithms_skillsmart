1) набор тестов суперклассов, который должен автоматически запускаться и успешно проходиться для дочернего класса. 
Привел 1 пример (Example1), кажется, не совсем удачный.
Зачастую в проекте, используется наследование конкретной абстрактной реализации.
И этого принципа не придерживаемся, но теперь взял себе на заметку.

2) полиморфизм подтипов

- Example 2, иерархия типов персон (LegalRepresentative, Registrator) являются персонами, но отделены в конкретные типы.
зачастую используется не корректно, в родительском классе был добавлен метод AsLegal, для представления персоны в виде LegalRepresentative,
если она таковым является.
Полиморфизма подтипов в функциях практически нет.
Потому что здесь нужно было использовать композицию, а не наследование :) 
LegalRepresentative - это представитель бизнеса, который привязан к персоне, то есть имеет с ней связь.

- Example 3 - Preonboarding параметры, есть базовый параметр преонбординга и есть конкретные реализации.
здесь принцип явно соблюдается, интерфейс принимает базовый класс для добавления нового параметра.

- Example 4 - документ может быть загружен с 3-мя разными состояниями, Pending, Error, Success.
Здесь нарушаем принцип LSP, поскольку приводим конкретную реализацию к заранее известному типу.
Верное решение - сделать метод обработки конкретного запроса на документ, в конкретном типе И использовать реализацию интерфейса, а не наследование.


Итого
1) Пойду перечитывать типы наследования из курсов по ООАП :)
2) Взял себе за правило, использовать наследование, только когда есть равноправные объекты с небольшими отличиями;
3) Взял себе за правило, использовать набор тестов суперклассов, чтобы другие разработчики не ломали, логику существующих родительских классов.


