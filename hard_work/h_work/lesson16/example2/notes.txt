До - писалось тем же человеком, что и первый пример. 
Схожая проблема, есть сервис, который по сути является оберткой над базой CRUD действия.

и далее каждый конкретный тип тикета, использует этот сервис как умного помощника для работы с базой.
внутри сервиса используется StorageService работающий с БД, при этом много где есть места в коде, где напрямую для доставания тикетов ходим в базу
а потом используем сервис для обновления статуса.

Состояние тикета отделено от сервиса его исполнения и передается как ITicketContext зачем-то, в конкретную реализацию тикета,
хотя итак понятно что там будут данные конкретного тикета (внутри делается каст к нужным данным)

Основной функционал 
1) нужно уметь универсально работать с тикетом по его типу
2) вызывать различные операции по конкректному тикету
3) иметь возможность доставать тикеты по различным условиям

(в основном смотрел на организацию тикетов как таковых и на операции, особенно в контексте создания тикета просто его типу)

Пробуем более четко определить границы через интерфейсы и создание АТД.

Не думаем о том как будут храниться объекты - (сейчас Postgres, конечно такие ООП модели куда проще сохранять в MongoDb)

Для этого делаем следующее

1) Отделяем логику поиска тикетов в отдельный интерфейс/-ы (Queries), а операции работы с тикетом оставляем в конкретном тикете (что-то похожее на DDD получается :) )
Если нужно сделать операции над тикетом, то уже вызываем фабрику по ticketid
2) Всеравно нужно иметь возможность универсально получать тикет по Id.

Дополнительно получаем нормальное версионирование тикетов, без костылей (в фабрике при получении можем создавать на основе версии из бд нужную реализации по версии тикета).

Итого
Достаточно объемная задача, нужно еще много продумывать, получилось чуть лучше и много выделено явно, но много также и недостатков (сохранение состояния, проброс данных в конкретный тикет, работа с фронтом).