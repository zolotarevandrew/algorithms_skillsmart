1) сбор недостающей информации онбордингу

Сейчас, чтобы добавить новый шаг для сбора данных, приходится:
- писать кастомный запрос получения данных в досье клиента;
- писать кастомный запрос отправки данных в досье клиента;
- добавлять  новый ключ метаданных онбординга
И описывать новый триггер перехода на шаг;
- напиливать кастомную логику внутри шага.

Идея - иметь набор недостающих и текущих параметров, которыми легко оперировать.

Триггер на шаг будет смотреть на конкретно недостающие параметры, нюанс в том, что в разных странах они могут быть разные, 
но это тоже легко решается - если досье клиента будет предоставлять список, который необходимо дособрать по конкретной стране.

2) постоянно новые кастомные запросы для отправки данных из онбординга в досье

Решаем проблемы с досье из пункта 1.

Чтобы на каждый чих не создавать апи для получения недостающих данных и отправки собранных данных.

Заводим тип 
DossierParameter
Генерик и обычный абстрактный класс
- тип енумка
- значение
- связанная сущность и ее тип

добавляем реализацию новых параметров с кастомными методами, типы связанных сущностей будут фиксированны, останется указать связь по нами любым id:)
делаем общую библиотеку.

При получении параметров в досье, их можно всегда просто вставлять в базу, соот-во получаем историчность из коробки, и понимание когда и кто заполнял какой из параметров.

Затем в момент передачи заявки на ревью, можно собрать уже полноценную версию досье, из недостающих параметров,
взяв последние значения, ведь в момент передачи на ревью, никто данные изменять уже не будет, 
кроме ручных вмешательств аналитиков (возможно придется заблокировать изменение данных в такие моменты)

Делаем следующие апи методы:
- получить параметры и недостающие параметры;
- заполнить список параметров, просто пишем в базу;
- получить конкретные дополнительные сущности (персоны, связанные компании).

Итого для пунктов 1 и 2 получаем
- максимально простое добавление нового шага для сбора данных;
- Однотипные методы апи, больше не напиливаются, в редких случаях можно завести новые;
- каждый разработчик понимает, что он делает и как учавствует в процессе.

3) Ревью данных досье
Сейчас для ревью данных досье, делается следующее в отдельном микросервисе
- тянутся данные досье, для того, чтобы понять какие задачи нужно триггерить;
- данные копируются в задачу;
- после ревью часть данных переезжает обратно в досье.

Сделано оно максимально криво и тяжело поддерживается - надо напиливать возврат и сохранение данных лишний раз (прямо как в пункте 1 и 2)

Правильнее поменять концепцию и делать это в сервисе досье.

- создаем версию данных досье с меткой ревью.
Если аналитик отредактировал данные при ревью, помечаем предыдущую версию данных не активной и создаем новую;

- Берем данные досье для ревью и понимаем какие задачи надо стриггерить;

- задачи имеют доступ к версии  данных досье. Данные не копируются в задачи;

- в конце ревью версия, становится актуальной.

Итого получаем:
- убираем необходимость напиливать методы направо и налево;
- аудит из коробки;
- простота поддержки задач, поскольку нет внутреннего состояния;

4) возврат данных на шаге онбординга клиенту

Ранее данные на шаг клиенту, тянулись каждый раз заново из досье для отображения текущего состояния.

причем делается это на каждое открытие шага.
(Напиливали методы, которые возвращали данные досье, засабмиченные клиентом)

по завершению шага, мы уже не даем ничего редактировать, процесс ушел дальше, шаги зависимы друг от друга.

Чтобы решить проблему:
данные которые клиент подтвердил на шаге храним у себя и отображаем их при возврате на шаг не редактируемыми;

Итого получаем историю засабмиченных данных клиентом и решаем проблему напиливания лишних методов досье и используем новый общий механизм для работы с шагами.

5) переходы между статусами задач для ревью досье

Сейчас переходы между статусами задач сделаны на камунде, логика унесена в процесс и есть общий блок SetTicketStatus.

От этого одни проблемы, никто не может понять, как задача двигается по статусам - в камунде по сути блок схема..

Решается просто переносом статусной модели в код, она линейная, возможно стоит внедрить state machine.

Итого получаем:
- простое добавление новых статусов;
- легко исправить конкретную задачу, изменить статусную модель;
- разработчики понимают, что они делают.


Итого -  в рамках задания, смог предложить решения ряда текущих архитектурных проблем - более чем прекрасный результат :)
Да и с учетом того, что изменять уже работающую систему тяжело, приходится думать как это сделать относительно бесшовно.
Собираюсь еще детальнее прорабатывать далее.