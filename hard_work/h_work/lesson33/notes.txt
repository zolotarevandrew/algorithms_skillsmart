Хорошим примером здесь будет - какие-то временные настройки на уровне приложения (в памяти или в редисе) относящиеся к конкретной сущности.
В данном случае есть пользователь, и мы хотим иметь связь с настройкой троттлинга по самой сущности, не затрагивая основной класс.
Если класс является записью record - то для одинаковых объектов будут одинаковые хэши (но могут быть проблемы со списками), поэтому я все же завязался на id уникальный идентификатор + кастомный ключ. 
В c# это делается просто через Extension методы. 

В данном случае остается связь с основным объектом, но логика и хранение полностью отделены от основной закрытой сущности, которая наверняка уже перегружена.
Здесь можно было бы придумать какой-то миксин для такой встраиваемой функциональности, но кажется это будет овер инжинирингом. 

При желании статический словарь с метаданными, можно подгружать из редиса при старте приложения и сделать синхронизацию при изменении объекта, не сильно усложняя текущую реализацию.

Усложнения модели данных я здесь точно не вижу, но поскольку часто нужно что-то хранить не в памяти, а в базе данных, 
придется вводить понятие метаданных пользователя, с которыми уже будет сложнее работать.
А для простого расширения парой полей - конечно же модель со словарем самое лучшее решение.