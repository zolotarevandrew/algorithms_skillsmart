1) зависимость фреймворка
Был небольшой проект
Где много использовался entity framework orm, 
dbcontext инжектился в разные места, по факту проект сильно зависел от entity framework, 
Выделили все в отдельный слой хранения, закрыли интерфейсами, впрочем ничего нового.
Делал это осознанно, потому что была необходимость делать нормальные сырые запросы через dapper, было время на рефакторинг.

Entity framework тогда был еще не так хорош.

2) зависимость расшаренного формата
Например выделяли в камунде общий json контракт, который как переменная выходила из одного обработчика, в другой как входная переменная.
Решал несколькими способами
- добавлением новых полей, при простых изменениях
- версионированием процесса, в зависимости от версии бралась другая переменная
- помечал блоки obsolete и заводил новые с новой логикой

Здесь было 60% на 40%, где то делал осознанно, где то экспериментировал

3) зависимость зависимости
Был один интересный пример, джуну дали починить баг, в котором после релиза нашли "зависимость зависимости", опытным путем отката)
Был обычный статический маппер статусов верификации из бд на статусы слой бизнес логики (статус видеоидентификации). 
Как оказалось для приглашенных тим мемберов в команде, был специфичный баг связанный с "костылями" переключения верификации на видеоидентификацию.
Итого поправили маппер и сломался специфичный кейс видеоидентификации тим мемберов, найти сходу было тяжело.
Отделили статусную модель видеоидентификации тиммембера от основной, поправили костыли и решили проблему на корню.

4) зависимость краша
был объект заявки на пропуск, который хранил ссылку на связанное транспортное средство, 
но поскольку разделение ответственности изначально было сделано не правильно, 
много где рядом с заявкой на пропуск приходилось доставать из репозитория и транспортное средство.
То есть часто заявка напрямую зависела от модуля транспортных средств (ТС).
Пришла задача сделать доработки по ТС, добавили несколько полей, и оказалось что для некоторых заявок перестала открываться страница конкретной заявки,
отдавалась 500, явная проблема была в зависимости зависимости, которая приводила к крашу. Ошибочные поля поправили.
Но также в важных местах пришлось разделять связь ТС - заявка на пропуск, что не решило проблему на корню, но сделало ее менее критичной.

5) Зависимость перебрасывания 
Для рассылки уведомлений о вышедшем пропуске использовали использовали два сервиса отправки смс.
Проблема изначальная - первый великолепный сервис, часто присылал странные ошибки, из-за которых, сообщения до клиента просто не доходили.
Второй сервис, был более стабильный, но также более дорогой.
Разобрав все за и против, попытавшись бороться с ошибками первого сервиса, решили перейти на второй более дорогой сервис,
в 99.9% cлучаев ошибок больше не было.
Также убралась сложная логика перебрасывания, которую трудно было разобрать.

По-хорошему надо иметь отдельную точку входа notify, которая бы перебрасывала на нужный смс сервис, следила за доступностью каждого из них 
и была отказоустойчивой.

6) зависимость инверсии
На проекте активно используется DI контейнер,
Как таковые проблемы с этим, вылезают только при тестировании, когда контейнер не может зарезолвить зависимость, но решается достаточно просто и это зачастую человеческий фактор.

Не встречался со сложными случаями, которые бы стреляли в продакшене. И ломали бы каскадно два модуля или класса одновременно.

Я не фанат контейнеров и периодически создаю обьекты через new напрямую в коде, передавая туда нужные зависимости.

Примера тут не приведу, но делаю такое не автомате, а всегда продумываю.


7) Зависимость зацикливания
Встречал на практике пару раз случаи зацикливания.
Был сложный код переходов по экранам. Проблема циклической зависимости вылезла при тестировании.

Делалось естественно неосознанно.

Решил с помощью отделения общей логики в отдельную абстракцию.

8) Зависимость высшего порядка
Не могу вспомнить адекватный пример, 
Была библиотека на .net для работы с файлами из s3 хранилища, в одном из методов использовался reactive extensions для event driven программирования.
Я использовал этот метод, по факту там использовался код вызывающего приложения и конечно же в моем случае код работал в 50% из 100.
Описал issue в github, решил с помощью написания собственного простого метода, который использовал рефлексию и вызывал один другой закрытый метод.

Если бы делал сам что-то подобное, скорее всего, делал бы неосознанно.

Выглядит так, что стоит рассматривать библиотеку, как набор абстракций, которые вызывающий код может реализовать, чтобы построить что-то свое, такое должно решать большую часть проблем.

9) зависимость большинства
Для проверки штрафов ТС (транспортных средств) используется 3 разные системы одновременно) поскольку каждая из них имеет проблему с данными, приходится собирать из трех источников и мерджить.

Делалось это максимально осознанно, поскольку интеграция с государственными сайтами, это самоубийство.
Решить такое можно собственной интеграцией с официальным источником, но это дорого и трудозатратно.

Пример также, возможно не супер уместный.

Итого - зависимости, достаточно сложная тема, я стараюсь жестко ограничивать взаимодействие между модулями, но оказывается этого недостаточно.
Видимо нужно делать регулярное ревью своего кода, на каждый из описанных типов зависимостей, чтобы качество системы было на уровне.
Пока что увидеть их достаточно проблематично.