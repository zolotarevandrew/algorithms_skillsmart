1. Зависимость фреймворка

зависимость флоу машины шагов онбординга от библиотеки stateless.

Если говорить про основное свойство, корректность переходов между шагами - то оно не зависит от библиотеки 
и поскольку реализованы собственные абстракции и поиск в глубину, просто использующие конфигуратор состояний из библиотеки.
условно stateless является просто хранилищем в памяти, которое легко можно заменить на что-то другое, без общего вреда системе.
(есть множество тестов)


2. Зависимость расшаренного формата.

передача данных между блоками в Camunda, ранее выносился класс в общую библиотеку,
которую использовали 2 взаимодействующих микросервиса.
Выходит лучшим решением является держать в общей библиотеке интерфейс, а реализацию в каждом микросервисе.
Таким образом, мы можем делать изменения на каждой из сторон, просто следуя общему формату.


3. Зависимость зависимости.

Интересная проблема, возьмем два микросервиса онбординга и хранилища данных на своей лицензии, границы двух микросервисов размыты, 
и каждый ранее мог ходить в каждый и изменять данные в каждом (Писать Http методы), поскольку не было нормального разделения на команды.
Теперь поскольку одна команда отвечает за микросервис онбординга, а вторая за хранилище данных на своей лицензии.
Взаимодействие будет происходить только по описанным контрактам, и будет контролироваться (лидом мной), чтобы избегать таких зависимостей зависимостей.
Первый сервис пошел во второй, а второй в первый асинхронно.. 


4. Зависимость краша.

Уже упомянал, онбординг использовал сервис поиска данных по бизнесам, 
интеграции в котором могли периодически падать, и новых клиентов не пускало в онбординг,
потому что на первом шаге всегда проверяло наличие компании в реестре.
Здесь была четкая зависимость краша, решилось достаточно просто,
внутри онбординга, просто сделали try catch на эту проверку + таймаут 20 секунд, 
и пользователь всегда гарантированно сможет попасть в онбординг в течении этого времени, просто придется заполнять часть данных руками.
вне зависимости от того были ли тех.работы в каких-то бизнес реестрах. 


5. Зависимость перебрасывания.

Здесь не могу привести адекватный пример. Перебрасывание кажется достаточно дорогой операцией.

Поддерживать несколько интеграций/cервисов одновременно - может быть дорого и тяжело, ну и как было описано, один сервис может быть не стабильнее другого
и хуже в качестве, а оно может повлиять на клиентов.

Если же есть выбор и качество плюс минус соответствует у двух или даже трех сервисов/интеграций, то конечно стоит делать логику перебрасывания.
Но понимать последствия данного решения, если риски реально оправданны.

Ну и стоит задумываться, об асинхронной модели, чтобы система могла сама восстановится после сбоя внешних систем, внезависимости от перебрасываний.


6. Зависимость инверсии.

Ничего адекватного из практики найти не могу.

Но думаю здесь также нужно уметь защищаться и понимать, сможет ли компонент работать при отказе внешнего компонента.
Ошибки связанные с DI, тема сложноватая, здесь надо грамотно проектировать систему типов, чтобы динамических сбоев не возникало (я пока так не умею :) )

7. Зависимость зацикливания.

Был реальный следующий инцидент на продакшене:
- Микросервис онбординга получил 11000 персон, отправил 11000 мессаг в Рэббит, его получил другой сервис
- другой сервис, начал запрашивать онбординг на каждую из 11000 мессаг, и тащить оттуда персон, в каждом запросе
из базы данных онбординга тащились эти 11000 персон заново.

Проблема решается просто, онбординг сам отвечает за свои данные и рассылает их сторониим сервисам,
должны быть определеные четкие границы.

Тоже самое сработает, если бы это было при взаимодействии модулей.

8. Зависимость высшего порядка
Есть также интересный пример, с онбординга во внешний сервис реестров по компании,
отправляется запрос на получение данных компании, формат регистрационных номеров разный в каждой из стран внутри Европы,
соот-во сервис "надеется", что регистрационный номер всегда приходит корректный, что неверно.
Может просочится ошибка, стоит добавлять предусловие валидации, на каждую реализацию поиска в конкретной стране или в конкретной интеграции.

9. Зависимость большинства.

В рабочей практике пока с таким совсем не сталкивался.


Итого - выстроилось четкое понимание, как широко смотреть на взаимодействие между системами/модулями
как они могут повлиять друг на друга, в том числе на основные свойства.
Всегда стоит промнить про собственные границы, и расценивать риски отказа любых подсистем на разных уровнях.

На основе 9 типов зависимостей как уже писал, смогу приоритизировать доску с тех.долгом и доказать бизнесу, что, часть задач реально стоит усилий на их разработку.