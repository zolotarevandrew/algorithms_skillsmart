1) состояния персоны с возможностью изменения телефона и почты
меняем на иммутабельную версию (копирование на основе record-ов) + добавляем признак изменились ли данные.

В идеале, конечно, изменить конструкторы Email, Phone, чтобы они возвращали некий Result type для невалидных значений и потом это можно было
chain-ить с вызовом Change, который также бы возвращал некий Result type, но это уже совсем другая история..

2) Тут скорее про инверсию управления в целом
- избавились от явного dispose/open connection/begin+commit transaction, не даем клиенту открывать закрывать connection транзакцию самостоятельно;

3) Завершение сессии
Убрал лишний флаг force - использовался только для тестирования, можно сделать отдельный метод ForceFinish.
Проблема такая же как и в пункте 1, хотелось бы chain-ить операции.
В данном случае, на успешный Finish сессии, нужно навешивать дополнительный IO обработчик в логике - для изменения состояния в базе и паблиша сообщения.
Это решается также через IoC, пробросом функции высшего порядка по завершению сессии, но не хочется мешать чистую бизнес логику с IO и tasks.
Можно в целом было сделать отдельный тип FinishedAdditionalQuestionSession обертку с методом Apply, которая бы вызывалась только для завершенной сессии.
Не стал заморачиваться - посмотрю в сторону библиотек для функциональщины в c#, чтобы писать такой код более быстро и просто.

Итого - возьму себе иммутабельность и local reasoning на вооружение, код реально проще тестировать, поддерживать, разбираться.