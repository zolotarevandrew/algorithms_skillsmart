Тест 1 - ComplexLegalFormComplexityServiceTests
сервис проверки является ли форма компании комплексной - (одна из 5 или 10 проверок комплексности).
из самих тестов не особо понятна суть проверок.
зашита константой - какая-то комплексная форма руками, которая в самом сервисе сравнивается с жестко заданным конфигом.

основная абстракция - проверить является ли легал форма компании комплексной?

1) интерфейс будет принимать на вход типизированный контракт LegalFormComplexityRequest с полями LegalFormId, OldLegalFormId
нам не нужно зависеть от всех данных компании.
2) заводим отдельную абстракции комплексности внутри этого сервиса (чтобы не зависеть от конфига - сейчас сильно завязано именно на конфиг)

два варианта
 
- Func<> - прямо инжектим функцию в сам сервис при создании, которая по Guid легал формы, скажет комплексная она или нет.
будет куда более простым вариантом (не завязываемся на конфиг).
и можем написать кастомную функцию комплексности - мокировать каждый раз в тесте.

- Интерфейс - инжектим интерфейс в сам сервис при создании, почти тоже самое что функция, но чуть сложнее, нужно писать лишнего кода.

отдельно уже сможем написать тесты на конкретную имплементацию функции комплексности.

Итого в тестах будет явно видно, что при изменении функции комплексности по легал форме, получаем нужный результат в тестах.
Также проверяем 3 теста
- пустую легал форму
- OldLegalFormId
- LegalFormid

Тест 2 - IPCheckResultAnalyzerTests
анализатор ip check-ов, который говорит нужно ли деклайнить счет.

совсем странно привязывать IpCheck-и к деклайну счета.
Результат ipcheck-ов, может приводить к деклайну счета - но это уже другая абстракция, сейчас же смешано все.

основная абстракция - проверить нужно ли производить деклайн по результатам ip проверок?

Правильнее выглядит
- иметь абстракцию IPCheckResultAnalyzer с методом Analyze(EIpCheckResult[] checks)
а на выходе иметь типизированный список полученных проверок - IPCheckResult(IPCheckResultType[] Types)
IPCheckResultType (RiskyAsn, Other..)
Пишем отдельные тесты для IPCheckResultAnalyzer

- по месту конкретной проверки деклайна (MessageHandler,Service) написать тест, который будет мокировать
IPCheckResultAnalyzer и проверять что при получении определенных результатов будет происходить деклайн.

итого если захотим поменять реализацию ipcheckanalyzer легко это сможем сделать, не затрагивая саму логику деклайна. 


Тест 3 - GermanVersionRouterTests
роутер на германскую версию онбординга - проверяет на какой банк и версию онбординга нужно редиректить

основная абстракция - на какой банк и версию онбординга редиректить, при заданных условиях преонбординга.

вроде бы здесь все адекватно, понятная абстракция и понятные результаты проверок.

единственное код инициализации  InitRq, надо убрать и переделать на явную передачу в метод роутинга.
тогда будет понятнее.


Тест 4 - DeactivatePersonSumSubDocumentsMessageHandlerTests

основная абстракция - деактивировать документы в хранилище документов, что и проверяется.


Тест 5 - AdditionalQuestionsAobBannerServiceTests
сервис баннеров для доп.вопросов

сходу не совсем понятна абстракция и что проверяют сами тесты.
есть два метода SetHasUnansweredQuestions, SetHasNoUnansweredQuestions.

основная абстракция - активировать/деактивировать баннер c типом AdditionalQuestions.

- при активации проверяем - что отправится нужный пуш для обновления баннера и статус станет активным.
- при деактивации, проверяем что статус баннера изменился на неактивный.

упустил на код ревью, до этого проекте завел нормальную абстракцию активации/деактивацию аоб баннеров - полиморфную, с возможностью кастомных имплементаций).
здесь просто изобрели велосипед.



Итого - сходу не сразу понял, про зависимость от реализации.
Но все-таки разобрался и смог увидеть в чем была проблема, описанных тестов.

Для себя выделил следующий алгоритм написания качественных тестов:
- выделяем основную абстракцию, что делает сервис;
- понимаем, что будет проверяться в тестах, выделяем свойства корректности, смотрим на спецификацию;
- если видим, явную зависимость от реализации, используем моки/ выносим отдельные реализации в абстракции/функторы;

