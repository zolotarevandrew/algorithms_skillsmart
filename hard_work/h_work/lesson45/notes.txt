1) досье кdлиента

Есть проблема, данные из досье клиента нужны многим другим микросервисам.

Так получилось, что люди с других команд начали напиливать API методы, ходя в базу за нужными данными - контроля со стороны команды не было.
(Доменного слоя тоже нету - все методы просто ходят в базу).

Потому появились методы типа
/card-delivery-options
/onboarding-legal-representatives

Не относящиеся к досье напрямую.

При этом в каждом методе сущность из БД каждый раз достается полная.(select *)

Универсальной апишки не было и пока не предвидется.

Решение выглядит следующим образом:
- повышаем информационную избыточность, делаем апи методы, которые возвращают полную информацию по категориям сущностей, на основе которой другие команды смогут построить свой флоу, без привлечения команды разработчиков досье клиента.

(Условно если сейчас более 10 методов, по возврату данных по компании сокращаем их до 1-3) 

На данный момент, переделать я это не смогу.

Но буду задавать направление - плюс переход на grpc.

(поскольку создание grpc контрактов более сложная операция - заставит хотя бы слегка разработчиков думать что они делают)


2) Документы связанные с сущностями (Example2)

в версии до, есть только 1 урезанный метод получения активного документа - Task<ActiveDocument?> GetLastActiveOrDefault(DocumentRelation relation, EDocumentType documentType);

в версии после возвращаем группу документов - Task<DocumentsGroup> GetRelated(DocumentRelation relation, params EDocumentType[] documentTypes);
причем теперь можем получить как активные так и неактивные документы из группы.

Добавив понятие DocumentsGroup - уменьшаем количество будущих изменений самого интерфейса, будем расширять само понятие группы и доступные методы.


3) Сервис дата коллекции (Example3)
Дата коллекция это сущность для сбора данных на онбординге, имеет свои статусы соот-во.
Каждая дата коллекция содержит набор дата поинтов - которые нужно собрать с клиента.


Сейчас для получения состояния дата коллекции есть 3 метода
- GetClientState
- BuildInfo
- GetState

непонятно какой нужно использовать в конкретном случае, оказывается они просто отдают разные разрезы
- GetState - делает два запроса в базу (достаем саму сущность дата коллекции и привязанную к ней коллекцию дата поинтов)
при этом json данные дата поинта не заполняются 
- BuildInfo - вызывается вместе с GetState, и здесь уже заполняются данные только требуемых датапоинтов, причем заполнение идет в цикле
то есть еще + n запросов к базе.

- GetClientState - вызывается вместе с GetState и на основе типа дата коллекции строится кастомная модель для отображения клиенту, включает в себя
высчитывание статуса на основе кастомных данных дата коллекции + текст баннера
 
Очевидно, что методы BuildInfo + GetClientState - можно просто взять и выпилить.
Для этого потребуется усложнить DataCollectionModel

- Сделаем этот класс абстрактным АТД и реализация будет уже на уровне отдельной дата коллекции; 

- Для каждого из дата поинтов либо сразу тянем json данные из базы, 
либо делаем Lazy поле, в которое уже инкапсулируем логику получения данных по требованию пользователя этого класса - но это опять же будет n запросов к базе.

- Высчитывание текста баннера и статуса дата коллекции делаем методами в АТД;
 

Итого - заметил важную вещь, что избыточность - по сути является продолжением полиморфизма. 
Позволяет покрыть большую часть кейсов использования и стратегически расширять такой код будет гораздо легче.
При этом если все сделать правильно, у программистов появятся сильные преграды для приляпок (хотя зачем я вру).