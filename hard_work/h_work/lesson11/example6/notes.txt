2.6. Приведение типов вниз по иерархии (родительские классы приводятся к дочерним).

Может иметься интерфейс или базовый класс.
В какой-то ситуации, может потребоваться использовать специфические методы, доступные только в дочернем классе. 
В этом случае придется приводить базовый класс к дочернему, чтобы использовать специфические методы.

Скорее всего, корневая проблема недостаточная или неправильная абстракция, 
нужно пересматривать абстракции и иерархию и приводить ее к новым требованиям.  
Также таким образом нарушается принцип подстановки Лисков.

Как пример, обработка событий, есть единообразный обработчик событий Event, у которого есть поле Type.
В зависимости от типа делается Type cast и обрабатывается конкретный вид события.

Решается просто, созданием нормальных generic обработчиков, в зависимости от указанного типа EventHandler<T>.

Или имеется массив объектов базового класса, и также приходится в цикле обрабатывать каждый тип по-своему,
в зависимости от своей реализации, также делается Type саst к конкретной реализации.

Скорее всего проблема с абстракцией, каждый такой случай надо разбирать индивидуально.



